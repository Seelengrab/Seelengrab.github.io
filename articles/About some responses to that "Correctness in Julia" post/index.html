<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/basic.css"> <link rel=stylesheet  href="/css/style.css"> <link rel=icon  href="/assets/favicon.png"> <title>About some responses to that "Correctness in julia" post</title> <header> <a href="/" class=blog-name ><span>Voyage:</span><span id=title >About some responses to that "Correctness in julia" post</span></a> <nav> <ul> <li><button class=theme-toggle > <div class=theme-sun >‚òÄÔ∏è</div> <div class=theme-moon >üåñ</div> </button> <li><a href="/articles/">Articles</a> <!--<li><a href="/tag/">Tags</a>--> <li><a href="/about/">About</a> </ul> <img src="/assets/hamburger.svg" id=menu-icon > </nav> </header> <ul class=franklin-content  id=tags > <li><a href='/tag/julia/'>julia</a><li><a href='/tag/correctness/'>correctness</a><li><a href='/tag/interfaces/'>interfaces</a><li><a href='/tag/formal_methods/'>formal_methods</a></ul> <div class=franklin-content ><h1 id=about_some_responses_to_that_correctness_in_julia_post ><a href="#about_some_responses_to_that_correctness_in_julia_post" class=header-anchor >About some responses to that &quot;Correctness in julia&quot; post</a></h1> <div class=franklin-toc ><ol><li><a href="#full_disclosure">Full disclosure</a><li><a href="#interfaces">Interfaces</a><ol><li><a href="#checkbounds"><code>checkbounds</code></a><li><a href="#the_meat_of_the_criticism">The meat of the criticism</a></ol><li><a href="#fixing_the_most_common_issues">Fixing the most common issues</a><li><a href="#performance_correctness">Performance &amp; Correctness</a><li><a href="#additional_tidbits">Additional tidbits</a></ol></div> <h2 id=full_disclosure ><a href="#full_disclosure" class=header-anchor >Full disclosure</a></h2> <p>I&#39;ve been using julia for about 5 years now, since right around 0.5 transitioned to 0.6. I&#39;m very active on Discourse and Slack, helping to answer beginner &amp; advanced user questions - sometimes in greater detail than anyone asked for. I frequent the issue tracker and try to participate in discussions surrounding the language and where it can do better, as well as the direction I personally would like to see julia go in the future. I do not, however, write julia as my dayjob - I don&#39;t have financial interest in making this language better.</p> <div class=imgcenter ><img src="./neat.jpg" alt="" /></div> <p>I also &#40;in part&#41; agree with the general sentiment expressed around <a href="https://yuri.is/not-julia/">the article recently written by Yuri Vishnevsky</a>, that julia code in general feels undertested &#40;though not in the way most commenters seem to think&#41;. This article is <em>not</em> a &quot;rebuttal&quot; of the issues presented and felt there - those are 100&#37; valid. If I were to run into them, I would feel &#40;and have felt, in similar situations&#41; just as defeated, especially when running into them as often as Yuri seems to have.</p> <p>Rather, I want this article to be about some of the responses and arguments people in various forums chose to give when the article was published. They broadly fall into a few categories, which I&#39;ll get into below, explain the issue in the context of julia and why the argument does &#40;or does not&#33;&#41; apply and can make julia better as a language.</p> <h2 id=interfaces ><a href="#interfaces" class=header-anchor >Interfaces</a></h2> <p>Let&#39;s start with the elephant in the room: Interfaces. As a first example, we&#39;ll use the same one Yuri used, in regards to <code>@inbounds</code> on types that subtype <code>AbstractArray</code>.</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> sum(A::<span class=hljs-built_in >AbstractArray</span>)
    r = zero(eltype(A))
    <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:length(A)
        <span class=hljs-meta >@inbounds</span> r += A[i]
    <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >return</span> r
<span class=hljs-keyword >end</span></code></pre> <p>This code has a bug, specifically a bug about what a valid index is. As written, it is not valid to use <code>@inbounds</code> here, because <code>A</code> may not have <code>1</code> &#40;or <code>length&#40;A&#41;</code> or any value inbetween&#41; as a valid index. The general gist I got from comments about this was that &quot;interfaces would have fixed this&quot;, but to me at least that isn&#39;t true - where would you place an interface boundary that a compiler can check such that this would be caught during compilation, when values of objects are not known? While julia is a dynamic language, it is very much compiled, so we definitely could add this &#40;provided it&#39;s not a breaking change&#41;.</p> <p>Alas, it&#39;s not that simple, because this piece of code already expects at least one interface to hold and requires of their caller to follow additional requirements on top of those. For one, here&#39;s the requirements for a type that want to subtype <code>AbstractArray</code>, i.e. to adhere to <a href="https://docs.julialang.org/en/v1/manual/interfaces/#man-interface-array">the interface defined for it</a>:</p> <ul> <li><p><code>size&#40;A&#41;</code></p> <ul> <li><p>Returns a tuple containing the dimensions of <code>A</code></p> </ul> <li><p><code>getindex&#40;A, i::Int&#41;</code></p> <ul> <li><p>&#40;if <code>IndexLinear</code>&#41; Linear scalar indexing</p> <li><p>This is the lowered form of <code>A&#91;i&#93;</code> on the left hand side of an assignment or other use</p> </ul> <li><p><code>getindex&#40;A, I::Vararg&#123;Int, N&#125;&#41;</code></p> <ul> <li><p>&#40;if <code>IndexCartesian</code>, where <code>N &#61; ndims&#40;A&#41;</code>&#41; N-dimensional scalar indexing</p> <li><p>This is the lowered form of <code>A&#91;i, j, ...&#93;</code> on the left hand side of an assignment or other use</p> </ul> <li><p><code>setindex&#33;&#40;A, v, i::Int&#41;</code></p> <ul> <li><p>&#40;if <code>IndexLinear</code>&#41; Scalar indexed assignment</p> <li><p>This is the lowered form of <code>A&#91;i&#93; &#61; v</code></p> </ul> <li><p><code>setindex&#33;&#40;A, v, I::Vararg&#123;Int, N&#125;&#41;</code></p> <ul> <li><p>&#40;if <code>IndexCartesian</code>, where <code>N &#61; ndims&#40;A&#41;</code>&#41; N-dimensional scalar indexing assignment</p> <li><p>This is the lowered form of <code>A&#91;i, j, ...&#93; &#61; v</code></p> </ul> </ul> <p>There are some optional functions the code above uses for additional performance or to make code easier to write:</p> <ul> <li><p><code>length&#40;A&#41;</code>, from the optional methods of the <code>AbstractArray</code> interface - this defaults to <code>prod&#40;size&#40;A&#41;&#41;</code>.</p> <li><p><code>eltype&#40;A&#41;</code>, from the <a href="https://docs.julialang.org/en/v1/manual/interfaces/#man-interface-iteration">optional methods of the iteration interface</a> - this defaults to <code>Any</code> &#40;julias&#39; <code>Top</code> type in type lattice parlance&#41;</p> </ul> <p>Both of these are optional because they&#39;re not required to implement to make the basic operations using those interfaces work - but they can be customized to give other benefits, like better performance in the case of <code>eltype</code> or ease of use in the case of <code>length</code>.</p> <p>To return to our bug - notice how the <code>AbstractArray</code> interface <em>does not specify what you do with the given index</em>. In particular, it does <em>not</em> require that all indices of all types that subtype <code>AbstractArray</code> begin with <code>1</code>. This makes things like <a href="https://github.com/JuliaArrays/OffsetArrays.jl">OffsetArrays.jl</a> work in the first place. <a href="https://github.com/giordano/StarWarsArrays.jl">Some</a> other <a href="https://github.com/giordano/RandomBasedArrays.jl">packages</a> take that that to a &#40;probably not as useful&#41; logical extreme.</p> <p>Importantly though, since the interface does not give a semantic guarantee about what indices are supposed to mean when you&#39;re implementing the interface &amp; subtyping <code>AbstractArray</code>, the compiler cannot check that how you got your indices is correct, just from the <code>AbstractArray</code> interface alone because there is no notion of &quot;what is a correct index&quot; in that interface. That&#39;s why the big warning is there in the documentation of <code>@inbounds</code>. This could of course be added to the interface, but that would require either a breaking change to force all existing implementations to conform &#40;that&#39;s not good&#41;, or a fallback implementation that then forces a boundscheck &#40;which wouldn&#39;t actually help, because existing faulty uses of <code>@inbounds</code> would still not allow that to happen&#41;. On top of this, even if such a requirement would be added to the <code>AbstractArray</code> interface, you quickly run into issues when you don&#39;t have a hardcoded iteration anymore:</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> foo(Arr::<span class=hljs-built_in >AbstractArray</span>, i::<span class=hljs-built_in >Int</span>)
    s = zero(eltype(Arr))
    <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> (i+<span class=hljs-number >2</span>):(length(Arr)-<span class=hljs-number >2</span>)
        <span class=hljs-meta >@inbounds</span> s += Arr[i]
    <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >return</span> s
<span class=hljs-keyword >end</span></code></pre> <p>For this to conform to the added bounds checking interface requires knowing what <code>i</code> is - or at least requires knowing some bounds on the values <code>i</code> can take on, on top of requiring the bounds checking code for the concrete type of <code>Arr</code> to be correct itself. Worse, if the bounds checking result depends not only on the type but on the concrete value, as is the case for <code>OffsetArrays.jl</code>, the compiler can&#39;t ever elide the check on its own simply because it fully requires knowing a runtime value at compile time. If it could, we wouldn&#39;t need <code>@inbounds</code> in the first place.</p> <h3 id=checkbounds ><a href="#checkbounds" class=header-anchor ><code>checkbounds</code></a></h3> <p>By now, someone probably remembers &#40;likely from implementing the <code>AbstractArray</code> interface themselves and wanting to elide bounds checking on their type with <code>@inbounds</code>&#41; that there actually is such a function providing exactly that interface: <code>checkbounds</code>. That however doesn&#39;t solve our problem, because as a matter of fact, <a href="https://github.com/JuliaArrays/OffsetArrays.jl/blob/4959bab649583bb118898671d2006ed8ea7716e1/src/OffsetArrays.jl#L412-L416">OffsetArrays.jl is using that for its bounds checking</a>&#33; Once again - the interfaces are all implemented correctly by <code>OffsetArrays.jl</code>. An interface doesn&#39;t help here when user code comes along and assumes more from their types than they guarantee.</p> <p>These issues are not exclusive to julia - there are whole <a href="https://github.com/google-research/dex-lang">research languages</a> dedicated to this problem. Even just confined to indexing, it is very far from solved. The situation right now, however, boils down to &quot;check every access or manage to prove &#40;or convince the compiler&#41; that you don&#39;t need to&quot;. Or just hope code review catches it - in my opinion the worst, if most human option.</p> <h3 id=the_meat_of_the_criticism ><a href="#the_meat_of_the_criticism" class=header-anchor >The meat of the criticism</a></h3> <p>I guess the general complaint is about having testing deeper embedded in our culture as julia developers, and while I don&#39;t disagree with that idea, I think that complaint is a bit.. difficult to &quot;fix&quot;, so to speak. Julia code in general seems well tested - lots and lots of packages have extensive testsuites and using CI for running them is deeply engrained in our culture &#40;at least from my POV - your mileage may vary after all&#41;. The trouble is of course that due to the extreme genericity julia code allows, it&#39;s much easier than in other languages to run into edge cases the original author didn&#39;t anticipate. In and of itself that&#39;s both a good and a bad thing - good because it allows the oft-touted interplay between packages that &quot;don&#39;t know about each other&quot; to just-work&#40;tm&#41; &#40;if implemented correctly&#41;, and bad because it means that the number of edge cases to consider is VASTLY larger than in more restrictive contexts<sup id="fnref:specifications"><a href="#fndef:specifications" class=fnref >[1]</a></sup>.</p> <p>In this context, &quot;testing your code&quot; very quickly transforms from &quot;just check a single interface implementation&quot; to &quot;formally prove that anyone that correctly implements the interface you require can also expect your code to work correctly&quot;. This is a priori infeasible - for one, you don&#39;t even have the concrete implementation of the thing you may get at hand when writing your tests, so you can&#39;t even properly fall back to &quot;just check a single interface implementation&quot;. This also has an upside - one comment mentioned that in Rust, if the author of some piece of code didn&#39;t anticipate a user of their datastructure to iterate over it, a user can&#39;t do anything other than wrapping the object and implementing the <code>IntoIterator</code> trait on their wrapper, while simultaneously having to forward all other parts of the wrapped object. In Julia, this <em>can</em> be added to the existing code post-fact - though doing so is called <code>type piracy</code> <sup id="fnref:piracy"><a href="#fndef:piracy" class=fnref >[2]</a></sup> and very much frowned upon. It&#39;s usually better to upstream such changes, if they are useful for more people and make semantic sense on the datastructure in the first place.</p> <p><table class=fndef  id="fndef:specifications"> <tr> <td class=fndef-backref ><a href="#fnref:specifications">[1]</a> <td class=fndef-content >Notably, interfaces don&#39;t help here either. While <code>interface</code> is often taken as &quot;requirements my code must adhere to&quot;, in practice and as its often implemented in compilers, it&#39;s nothing more than &quot;This type has these functions that operate on/with it implemented&quot;. If you add more conditions &#40;such as &quot;and the functions are implemented correctly&quot;, for whatever notion of &quot;correctly&quot; is appropriate here&#41; than this to your definition, you&#39;re into specification territory - a vastly different beast, leading right back to formal methods. Check out <a href="https://hillelwayne.com/post/spec-composition/">this blog post</a> by Hillel Wayne for a definition and some of the challenges that can arise with them. One way to alleviate this would be to use property based testing and automatic input generation - but that space has not arrived in julia &#40;<a href="https://github.com/Seelengrab/PropCheck.jl">yet</a>&#41;. </table> <table class=fndef  id="fndef:piracy"> <tr> <td class=fndef-backref ><a href="#fnref:piracy">[2]</a> <td class=fndef-content >Type Piracy: Implementing a method for a function &amp; object&#40;s&#41; you don&#39;t own in the &quot;This is my own code&quot; sense. In this example, a potential implementor neither owns <code>iterate</code> &#40;that&#39;s owned by <code>Base</code>&#41; nor the third-party library type. </table> </p> <h2 id=fixing_the_most_common_issues ><a href="#fixing_the_most_common_issues" class=header-anchor >Fixing the most common issues</a></h2> <p>I don&#39;t want to go on and on about how interfaces don&#39;t fix this, so let&#39;s take a look at both examples I gave and how they could be fixed, without getting rid of <code>@inbounds</code> in the loop, to keep performance up. Here&#39;s the first one:</p> <pre><code class="diff hljs">function sum(A::AbstractArray)
    r = zero(eltype(A))
<span class=hljs-deletion >-   for i in 1:length(A)</span>
<span class=hljs-addition >+   for i in eachindex(A)</span>
        @inbounds r += A[i]
    end
    return r
end</code></pre> <p>That&#39;s it. <code>eachindex</code> has as its contract to return an iterable object that produces all valid indices for <code>A</code>. As long as the implementation for <code>eachindex</code> on the concrete type of <code>A</code> is correct, our <code>@inbounds</code> is correct as well<sup id="fnref:statsbase"><a href="#fndef:statsbase" class=fnref >[3]</a></sup>.</p> <p>And here&#39;s the second one:</p> <pre><code class="diff hljs">function foo(Arr::AbstractArray, i::Int)
    s = zero(eltype(Arr))
<span class=hljs-addition >+   idxs = (i+2):(length(Arr)-2)</span>
<span class=hljs-addition >+   checkbounds(Bool, Arr, idxs) || throw(ArgumentError(&quot;Indices `$idxs` computed from argument `$i` would be out of bounds.&quot;))</span>
<span class=hljs-deletion >-   for i in (i+2):(length(Arr)-2)</span>
<span class=hljs-addition >+   for i in idxs</span>
        @inbounds s += Arr[i]
    end
    return s
end</code></pre> <p>This is not fundamentally different from checking indices into arrays computed from unknown values in other languages<sup id="fnref:zig"><a href="#fndef:zig" class=fnref >[4]</a></sup>.</p> <p>What I will agree on though is that this part of the machinery is underdocumented and not mentioned in the <code>AbstractArray</code> docs themselves. This is an actionable item that can and should be improved on. To be more precise: let&#39;s add <code>eachindex</code> to the optional methods to implement for types implementing <code>AbstractArray</code>. Additionally, <code>checkbounds</code> should be mentioned there as well, for implementing <code>getindex</code> correctly.</p> <p><table class=fndef  id="fndef:statsbase"> <tr> <td class=fndef-backref ><a href="#fnref:statsbase">[3]</a> <td class=fndef-content >The authors of the package in question acknowledge as much - it&#39;s just that they haven&#39;t had the time to fix those, since the code by now is 8 years old. That&#39;s older than <code>OffsetArrays.jl</code> and genericity about indices itself, for those taking notes. I don&#39;t think that excuses that those bugs are still around, but I can understand how that code hasn&#39;t aged gracefully and bitrot instead. </table> <table class=fndef  id="fndef:zig"> <tr> <td class=fndef-backref ><a href="#fnref:zig">[4]</a> <td class=fndef-content >Zig is an interesting one here - if we write an equivalent function in Zig, but mark both <code>i</code> as well as the bounds check as <code>comptime</code>, the compiler can actually elide that check, because we lifted the computation for the check to compile time by requiring all information required for it to be known at compile time. A similar thing can happen in julia - if <code>i</code> is a compile-constant &#40;or derivable as such&#41; and propagated into this function, the compiler may compute the bounds check at compile time as well and elide it at runtime. This is not a guarantee though and it&#39;s only an optimization that&#39;s done when it&#39;s actually safe to do so - in that case, even the thrown error is completely eliminated from the result. </table> </p> <h2 id=performance_correctness ><a href="#performance_correctness" class=header-anchor >Performance &amp; Correctness</a></h2> <p>One comment that stood out to me mentioned that a lot of these issues around correctness seem to crop up around code that&#39;s trying to be performant. The example given references <a href="https://github.com/JuliaLang/julia/pull/36543">this pull request</a>, where a bug in a function named <code>dayofquarter</code> regarding leap years was fixed. The comment to me felt like maybe trading performance for correctness would have been the better choice here, and that something along the lines of</p> <pre><code class="text hljs">start_of_quarter = quarterstart(date); (date-start_of_quarter).days</code></pre>
<p>instead of a lookup table for how many days into a quarter we are would have been better. Well, I&#39;m sorry to say, but this code too could have the exact same bug - it just shifts the &quot;correctness&quot; part to <code>quarterstart</code>. If that function instead has the leap year bug, you&#39;re no more correct than the previously broken version.</p>
<p>This, to me, comes down to the crux of the issue: Correctness is very, VERY hard. Most alternative formulations of algorithms that fundamentally express the same computation, once optimized performance wise, do little more than shift the correctness checks around. In the end, if you want to compute the same thing in all cases, you will have to handle the same edge cases, somewhere, somehow.</p>
<p>Quite a few comments also lamented that without provable correctness, we&#39;ll never be able to guarantee that it is correct and will always have bugs. Circular argument aside, proving correctness brings us firmly into <a href="https://en.wikipedia.org/wiki/Formal_methods">formal methods</a> territory. On one hand, I&#39;m excited that people seem to have such a high bar for julia that the language &#40;and its community&#33;&#41; is actually held to such a high standard that it&#39;s sort of implicitly expected to have correctness already built in. It means that people really do expect &amp; think about this stuff, which to me at least signals the start of a great change in how we do computing. On the other hand, I&#39;m annoyed by those same expectations, because formal methods is bleeding edge research that&#39;s, arguably, a niche topic in regular software engineering to date.</p>
<h2 id=additional_tidbits ><a href="#additional_tidbits" class=header-anchor >Additional tidbits</a></h2>
<p>I have quite a few more thoughts about interfaces, specifications, correctness, testing and how this should evolve in the future and/or how it could be done &amp; improved in julia. However, this is getting rather long, so I&#39;ll end it here. Suffice it to say that due to julia not having formal interfaces yet, we also haven&#39;t written ourselves into a corner with having to support a &#40;maybe suboptimal&#41; version that&#39;s just a rehash of an existing flavor of interfaces. As much as that weighs heavy, it also means that the design space is very free to be explored - and I do hope that it becomes a more centralized focus. I&#39;ll probably write up my thoughts about this in the near-ish future, together with what I view as a sort of &quot;what&#39;s the state of all of this in julia&quot; to give some context.</p>
<footer>
    <div id=meta >
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Sukera. Last modified: April 21, 2024.
    <a type="application/rss+xml" href="./feed.xml">
        <img src="/assets/rss.svg" alt="RSS Feed" class=rss-icon />
    </a>
    </div>
    <div id=love >
    Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>, the <a href="https://julialang.org">Julia programming language</a> and <span class=heart >‚ô•</span>!
    </div>
</footer>
</div>
    
    
        
<script>hljs.highlightAll();hljs.configure({tabReplace: '    '});</script>

    
    
<script>
const setTheme = function (newTheme) {
  var prefersDarkScheme = window.matchMedia("(prefers-color-scheme: dark)");
  var wasNull = newTheme === null;
  if (newTheme === null) {
    if (prefersDarkScheme.matches) {
      newTheme = "dark";
    } else {
      newTheme = "light";
    };
  };
  if (newTheme == "dark") {
    document.body.classList.toggle("light-theme", false);
    document.body.classList.toggle("dark-theme", true);
    document.querySelector(".theme-moon").style.display = "inline-block";
    document.querySelector(".theme-sun").style.display = "none";
  } else {
    document.body.classList.toggle("dark-theme", false);
    document.body.classList.toggle("light-theme", true);
    document.querySelector(".theme-sun").style.display = "inline-block";
    document.querySelector(".theme-moon").style.display = "none";
  }
  if (!wasNull) {
    localStorage.setItem("theme", newTheme);
  }
};
var currentTheme = localStorage.getItem("theme");
console.log(currentTheme);
setTheme(currentTheme);

var btn = document.querySelector(".theme-toggle");
btn.addEventListener("click", function () {
  var theme = document.body.classList.contains("light-theme")
    ? "dark"
    : "light";
  setTheme(theme);
});
var prefersDarkScheme = window.matchMedia("(prefers-color-scheme: dark)");
prefersDarkScheme.addEventListener("change", function() {setTheme(localStorage.getItem("theme"))});
</script>