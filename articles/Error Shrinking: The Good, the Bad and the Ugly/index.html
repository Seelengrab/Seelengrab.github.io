<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/basic.css"> <link rel=stylesheet  href="/css/style.css"> <link rel=icon  href="/assets/favicon.png"> <title>Error Shrinking: The Good, the Bad and the Ugly</title> <header> <a href="/" class=blog-name ><span>Voyage:</span><span id=title >Error Shrinking: The Good, the Bad and the Ugly</span></a> <nav> <ul> <li><button class=theme-toggle > <div class=theme-sun >‚òÄÔ∏è</div> <div class=theme-moon >üåñ</div> </button> <li><a href="/articles/">Articles</a> <!--<li><a href="/tag/">Tags</a>--> <li><a href="/about/">About</a> </ul> <img src="/assets/hamburger.svg" id=menu-icon > </nav> </header> <ul class=franklin-content  id=tags > <li><a href='/tag/julia/'>julia</a><li><a href='/tag/testing/'>testing</a><li><a href='/tag/errors/'>errors</a><li><a href='/tag/pbt/'>PBT</a><li><a href='/tag/suppositionjl/'>Supposition.jl</a></ul> <div class=franklin-content ><h1 id=error_shrinking_the_good_the_bad_and_the_ugly ><a href="#error_shrinking_the_good_the_bad_and_the_ugly" class=header-anchor >Error Shrinking: The Good, the Bad and the Ugly</a></h1> <p>Errors&#33; Love &#39;em or hate &#39;em, one thing is undeniable: we all encounter them, sooner or later. I&#39;ve been thinking about errors quite a bit recently, in part because of <a href="https://public.tecosaur.net/JuliaErrors.html">a recent post</a> by <a href="https://github.com/tecosaur"><code>@tecosaur</code></a> about improving the error experience in Julia:</p> <blockquote> <p>Julia‚Äôs error messages currently effectively communicate that an error has occurred, and the general nature of it, but fail to do much beyond that.</p> </blockquote> <p>The post mostly focuses on the presentation &amp; interactive side of things, which <em>really</em> needs some work &amp; better library support. There&#39;s one big thing that wasn&#39;t mentioned though: When we get an error, what options beside manually drilling into it do we have to debug such an error?</p> <h2 id=good_errors ><a href="#good_errors" class=header-anchor >Good Errors</a></h2> <p>First, let&#39;s set a baseline; what kinds of errors do we currently have that do a good job of communicating what the root cause is? Take <code>sin&#40;Inf&#41;</code> for example:</p> <pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > sin(<span class=hljs-literal >Inf</span>)
</span>ERROR: DomainError with Inf:
sin(x) is only defined for finite x.
Stacktrace:
 [1] sin_domain_error(x::Float64)
   @ Base.Math ./special/trig.jl:28
 [2] sin(x::Float64)
   @ Base.Math ./special/trig.jl:39
 [3] top-level scope
   @ REPL[2]:1</code></pre> <p>UX-wise, this is a good error&#33; We get a clear message what caused the error &#40;<code>Inf</code>&#41;, where it occurred &#40;in <code>sin</code>&#41;, why it occured &#40;the function is only defined for finite inputs&#41; and to top it off, the <em>type</em> of the error is specific to this kind of mathematical problem:</p> <pre><code class="julia-repl hljs">help?&gt; DomainError
search: DomainError LoadError DivideError InitError BoundsError AssertionError InexactError

  DomainError(val)
  DomainError(val, msg)

  The argument val to a function or constructor is outside the valid domain.

[...]</code></pre> <p>This is great, because it means programmers can check for the type in <code>try</code>/<code>catch</code> to explicitly handle <code>DomainError</code>s that weren&#39;t accounted for beforehand and can give domain-specific error messages.</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> process_angle(angle::<span class=hljs-built_in >Float64</span>)
    <span class=hljs-keyword >try</span>
        x = sin(angle)
        ... <span class=hljs-comment ># further processing</span>
    <span class=hljs-keyword >catch</span> e
        <span class=hljs-comment ># throw an application specific error that we know must have been user error</span>
        <span class=hljs-comment ># and can be displayed specially in our frontend</span>
        e <span class=hljs-keyword >isa</span> <span class=hljs-built_in >DomainError</span> &amp;&amp; throw(InputError(<span class=hljs-string >&quot;The input angle must be finite!&quot;</span>))
        <span class=hljs-comment ># fall back to a different kind of error that we perhaps show differently</span>
        <span class=hljs-comment ># and/or only write to a log</span>
        throw(GenericError(<span class=hljs-string >&quot;An Unknown error occured&quot;</span>))
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span></code></pre> <div class="admonition note"><p class=admonition-title ><code>throw</code> in <code>catch</code></p><p><code>throw</code> in a <code>catch</code> block keeps the existing errors around in a stack of errors, which can be inspected later on using <code>current_exceptions</code>.</p> </div> <h2 id=bad_errors ><a href="#bad_errors" class=header-anchor >Bad Errors</a></h2> <p>Of course, with good comes bad too; in particular, liberal use of the overly generic <code>error</code> leads to quite hard-to-work-with errors, as <code>@tecosaur</code> talks about in <a href="https://public.tecosaur.net/JuliaErrors.html">his blogpost</a>. Since the type of all uses of <code>error</code> are the same &#40;namely <code>ErrorException</code>, a quite awful name&#41;, it&#39;s not possible to handle different kinds of errors explicitly, and as a result a programmer always has to fall back to the most generic handling possible. Currently, there are 736 places in Base &amp; its standard library that use the <code>error</code> function &#40;as counted by grepping for <code>&quot; error\&#40;&quot;</code> in the language repo&#41;, and I&#39;m pretty sure those uses won&#39;t all have the same meaning.</p> <p>Why is this bad? Well, as <code>@tecosaur</code> writes, <code>ErrorException</code> contains nothing but a <code>String</code> that&#39;s intended for user display. A programmer has no way to interrogate what actually happened at runtime, and must defer to the user. If the error message is not written well or the context surrounding that call has a different semantic than the one the code path using <code>error</code> assumes, it&#39;s incredibly easy for users to be confused about what&#39;s going on. This is especially prone to happen when the source of the error and the higher level interface the user interacts with are far removed from each other. There&#39;s a good list of examples in <a href="https://discourse.julialang.org/t/please-stop-using-error-and-errorexception-in-packages-and-base/12096?u&#61;sukera">this discourse thread</a> from almost 6 years ago, so the problem is definitely not new.</p> <p>On top of this though, anyone wishing to <em>handle</em> that kind of error only has the raw string to work with, and can&#39;t customize the presentation of that error to the user. This is not exclusive to <code>error</code> though, <code>DomainError</code> from <code>sin</code> shares that same problem &#40;and <code>@tecosaur</code> mentioned much the same in his post&#41;.</p> <p>This annoyed me enough that two years ago, I <a href="https://github.com/JuliaLang/julia/pull/45366">made a PR</a> to the Printf standard library that changes all uses of <code>ArgumentError</code> thrown when parsing the format string to an <code>InvalidFormatStringError</code>, which contains metadata about what exactly &amp; where it went wrong. This is metadata is then used only during displaying to actually format the error message in a way that is good to read.</p> <p>Before:</p> <div class=imgcenter ><img src="./before.png" alt="Before the PR, old ArgumentError" /></div> <p>After:</p> <div class=imgcenter ><img src="./after.png" alt="After the PR, new InvalidStringFormatError" /></div> <p>This is crucial information&#33; Not only can there be multiple different locations where an error occured, but not having this information be part of the error itself means that anyone wanting to display that error differently has no chance of doing so, if all they&#39;re given is a <code>String</code> from an <code>ArgumentError</code>, <code>DomainError</code> or even <code>ErrorException</code>.</p> <h2 id=the_ugly ><a href="#the_ugly" class=header-anchor >The Ugly</a></h2> <p>Alright, we&#39;ve seen some good and some bad - I&#39;ve also teased some Ugly in the title, and it&#39;s time we get to that. See, I&#39;ve recently released a property based testing/fuzzing framework called <a href="https://github.com/Seelengrab/Supposition.jl">Supposition.jl</a> &#40;go check it out&#33;&#41;, inspired by the python library <a href="https://hypothesis.readthedocs.io/en/latest/">Hypothesis</a>. One of the really cool things Supposition.jl can do is find the minimal input that produces an error &#40;if one can occur&#41;. For example, if we want to fuzz <code>sin</code> we can relatively quickly find the <code>DomainError</code> with a very naive property:</p> <div class=imgcenter ><img src="./fuzz_domain.png" alt="Fuzzing to find a DomainError" /></div> <p>And all is well, since that is very much expected. For functions that have a range of values that can error, Supposition.jl tries to minimize the input that ends up throwing the error:</p> <pre><code class="julia hljs">julia&gt; <span class=hljs-keyword >using</span> Supposition

julia&gt; <span class=hljs-keyword >function</span> double_rotation(radians::<span class=hljs-built_in >Float64</span>)
           <span class=hljs-number >0.0</span> &lt;= radians &lt; <span class=hljs-number >2</span><span class=hljs-literal >œÄ</span> || throw(<span class=hljs-built_in >ArgumentError</span>(<span class=hljs-string >&quot;The angle is expected to be in radians!&quot;</span>))
           <span class=hljs-comment ># keep the result in radians</span>
           mod(<span class=hljs-number >2</span>*radians, <span class=hljs-number >2</span><span class=hljs-literal >œÄ</span>)
       <span class=hljs-keyword >end</span>

julia&gt; <span class=hljs-meta >@check</span> <span class=hljs-keyword >function</span> allAngles(angle=Data.Floats{<span class=hljs-built_in >Float64</span>}())
           double_rotation(angle) <span class=hljs-keyword >isa</span> <span class=hljs-built_in >Float64</span>
       <span class=hljs-keyword >end</span>;
‚îå Error: Property errored!
‚îÇ   Description = <span class=hljs-string >&quot;allAngles&quot;</span>
‚îÇ   Example = (angle = <span class=hljs-number >6.283185307179587</span>,)
‚îÇ   exception =
‚îÇ    <span class=hljs-built_in >ArgumentError</span>: The angle is expected to be <span class=hljs-keyword >in</span> radians!
‚îÇ    Stacktrace:
‚îÇ     [<span class=hljs-number >1</span>] double_rotation
‚îÇ       @ ./REPL[<span class=hljs-number >2</span>]:<span class=hljs-number >2</span> [inlined]
‚îÇ     [<span class=hljs-number >2</span>] allAngles
‚îÇ       @ ./REPL[<span class=hljs-number >35</span>]:<span class=hljs-number >4</span> [inlined]
‚îî @ Supposition ~/Documents/projects/Supposition.jl/src/testset.jl:<span class=hljs-number >275</span>
Test Summary: | Error  Total  
allAngles     |     <span class=hljs-number >1</span>      <span class=hljs-number >1</span></code></pre> <p>The input that Supposition.jl found is <code>6.283185307179586</code>, which is exactly <code>2œÄ</code>:</p> <pre><code class="julia hljs">julia&gt; <span class=hljs-number >2</span><span class=hljs-literal >œÄ</span>
<span class=hljs-number >6.283185307179586</span></code></pre> <p>which is the excluded upper bound that <code>double_rotation</code> requires.</p> <p>So far so good; we can easily adjust the test so only valid inputs are used:</p> <pre><code class="julia hljs">julia&gt; <span class=hljs-meta >@check</span> <span class=hljs-keyword >function</span> allAngles(angle=Data.Floats{<span class=hljs-built_in >Float64</span>}())
           assume!(<span class=hljs-number >0.0</span> &lt;= angle &lt; <span class=hljs-number >2</span><span class=hljs-literal >œÄ</span>)
           
           double_rotation(angle) <span class=hljs-keyword >isa</span> <span class=hljs-built_in >Float64</span>
       <span class=hljs-keyword >end</span>;
Test Summary: | Pass  Total  
allAngles     |    <span class=hljs-number >1</span>      <span class=hljs-number >1</span></code></pre> <p>and the property passes. Granted, the property here is very trivial, but it&#39;s these kinds of seemingly trivial properties that are great for looking for places that error unexpectedly and/or that should be documented. If you want to learn more about this kind of incremental documenting of valid inputs, I&#39;ve written about this extensively <a href="https://seelengrab.github.io/Supposition.jl/stable/Examples/docalignment.html">in the documentation of Supposition.jl</a>.</p> <p>Of course, <code>double_rotation</code> is committing a bit of a sin here, by simply using <code>ArgumentError</code> and a <code>String</code>. Imagine now someone comes along and thinks &quot;this error message is really bad, let&#39;s communicate which number exactly caused the error&quot;:</p> <pre><code class="julia hljs">julia&gt; <span class=hljs-keyword >function</span> double_rotation(radians::<span class=hljs-built_in >Float64</span>)
           <span class=hljs-number >0.0</span> &lt;= radians &lt; <span class=hljs-number >2</span><span class=hljs-literal >œÄ</span> || throw(<span class=hljs-built_in >ArgumentError</span>(<span class=hljs-string >&quot;The angle is expected to be in the interval [0, 2œÄ), i.e. in radians! Got: <span class=hljs-variable >$radians</span>&quot;</span>))
           <span class=hljs-comment ># keep the result in radians</span>
           mod(<span class=hljs-number >2</span>*radians, <span class=hljs-number >2</span><span class=hljs-literal >œÄ</span>)
       <span class=hljs-keyword >end</span>
double_rotation (generic <span class=hljs-keyword >function</span> with <span class=hljs-number >1</span> method)

julia&gt; double_rotation(<span class=hljs-number >42.0</span>)
ERROR: <span class=hljs-built_in >ArgumentError</span>: The angle is expected to be <span class=hljs-keyword >in</span> the interval [<span class=hljs-number >0</span>, <span class=hljs-number >2</span><span class=hljs-literal >œÄ</span>), i.e. radians! Got: <span class=hljs-number >42.0</span>
Stacktrace:
 [<span class=hljs-number >1</span>] double_rotation(radians::<span class=hljs-built_in >Float64</span>)
   @ Main ./REPL[<span class=hljs-number >39</span>]:<span class=hljs-number >2</span>
 [<span class=hljs-number >2</span>] top-level scope
   @ REPL[<span class=hljs-number >40</span>]:<span class=hljs-number >1</span></code></pre> <p>UX wise, this is an obvious improvement; unfortunately, Supposition.jl has no knowledge about this. Because the error message differs, the root cause of the error might be completely different too, and so Supposition.jl warns you that it got a different error.. for every input it tries:</p> <pre><code class="julia hljs">julia&gt; <span class=hljs-meta >@check</span> <span class=hljs-keyword >function</span> allAngles(angle=Data.Floats{<span class=hljs-built_in >Float64</span>}())    
           double_rotation(angle) <span class=hljs-keyword >isa</span> <span class=hljs-built_in >Float64</span>
       <span class=hljs-keyword >end</span>;
‚îå Warning: Encountered an error, but it was different from the previously seen one - Ignoring!
‚îÇ   Error = <span class=hljs-built_in >ArgumentError</span>: The angle is expected to be <span class=hljs-keyword >in</span> the interval [<span class=hljs-number >0</span>, <span class=hljs-number >2</span><span class=hljs-literal >œÄ</span>), i.e. radians! Got: <span class=hljs-number >3.690705114706145e155</span>
‚îÇ   Location = double_rotation at REPL[<span class=hljs-number >39</span>]:<span class=hljs-number >2</span> [inlined]
‚îî @ Supposition ~/Documents/projects/Supposition.jl/src/teststate.jl:<span class=hljs-number >109</span>

[...] <span class=hljs-comment ># repeat the above log entry for various minimized input values a bunch of times</span>

‚îå Warning: Encountered an error, but it was different from the previously seen one - Ignoring!
‚îÇ   Error = <span class=hljs-built_in >ArgumentError</span>: The angle is expected to be <span class=hljs-keyword >in</span> the interval [<span class=hljs-number >0</span>, <span class=hljs-number >2</span><span class=hljs-literal >œÄ</span>), i.e. radians! Got: -<span class=hljs-number >368.8491610835767</span>
‚îÇ   Location = double_rotation at REPL[<span class=hljs-number >39</span>]:<span class=hljs-number >2</span> [inlined]
‚îî @ Supposition ~/Documents/projects/Supposition.jl/src/teststate.jl:<span class=hljs-number >109</span>
‚îå Error: Property errored!
‚îÇ   Description = <span class=hljs-string >&quot;allAngles&quot;</span>
‚îÇ   Example = (angle = -<span class=hljs-number >368.84916108357675</span>,)
‚îÇ   exception =
‚îÇ    <span class=hljs-built_in >ArgumentError</span>: The angle is expected to be <span class=hljs-keyword >in</span> the interval [<span class=hljs-number >0</span>, <span class=hljs-number >2</span><span class=hljs-literal >œÄ</span>), i.e. radians! Got: -<span class=hljs-number >368.84916108357675</span>
‚îÇ    Stacktrace:
‚îÇ     [<span class=hljs-number >1</span>] double_rotation
‚îÇ       @ ./REPL[<span class=hljs-number >39</span>]:<span class=hljs-number >2</span> [inlined]
‚îÇ     [<span class=hljs-number >2</span>] allAngles
‚îÇ       @ ./REPL[<span class=hljs-number >43</span>]:<span class=hljs-number >2</span> [inlined]
‚îî @ Supposition ~/Documents/projects/Supposition.jl/src/testset.jl:<span class=hljs-number >275</span>
Test Summary: | Error  Total  
allAngles     |     <span class=hljs-number >1</span>      <span class=hljs-number >1</span></code></pre> <p>ultimately reporting <em>a</em> value &#40;the first one it found&#41;, but not one that&#39;s close to the actual boundary of the check throwing that error. The really unfortunate part of this is that a custom error type also doesn&#39;t help here, if it doesn&#39;t have some form of ordering defined on it as well. Supposition.jl has no choice - it has no knowledge about individual error types and whether or not you can order them. It <em>could</em> attempt to find an ordering through reflecting on the fields of the object it receives, but that&#39;s not stable either &#40;though it could work for things like <code>ArgumentError</code>&#41;. For example, what should happen when a field in the error object just isn&#39;t orderable?</p> <p>It gets worse: What if there are <em>actually</em> distinct error types being thrown for different inputs? How should they be compared? They may be completely unrelated and may not have an obvious ordering, even through reflection on the fields. The semantic meaning is application specific after all. My gut feel is that this case should really just fall back to ignoring the other errors and focusing on the one we already have, so that the two &#40;or more&#33;&#41; errors we encountered during shrinking can be dealt with by a developer seperately. That way, we&#39;re at least limiting the problem to comparing objects of egal type, and hopefully dealing with distinct failure modes too. From the POV of Supposition.jl, I&#39;ll probably provide a hook to let users define an ordering on their type, if there is one, defaulting to the current behavior if there isn&#39;t. The details of what an error exactly looks like is &#40;I think&#41; internal too, so while looking at the message of e.g. an <code>ArgumentError</code> can break in the future, it might be good to provide a default fallback for some of these too, to allow them to shrink better.</p> <p>This is the ugly part of errors; even when you have taken a bit more care to design them with good UX, they are still a non-standard exit condition that all of your tooling needs support for to take proper advantage of. &quot;Throw and forget&quot; doesn&#39;t really work all that well when you want to be smart about actually debugging them.</p> <div class="admonition note"><p class=admonition-title >Supposition.jl improvements</p><p>With <a href="https://github.com/Seelengrab/Supposition.jl/releases/tag/v0.2.0">v0.2.0</a>, Supposition.jl can now shrink <code>ArgumentError</code> well too, correctly finding <code>6.283185307179586</code>. This is a bit brittle though and can get worse again if the error message string contains lots of unrelated data too, so using a better error is still important.</p> </div> <h2 id=conclusion ><a href="#conclusion" class=header-anchor >Conclusion</a></h2> <p>Alright, this about sums it up; there are good &amp; simple things you can do with errors in Julia that help users to debug their code, but even those aren&#39;t good enough when it comes to writing fuzzable errors. There&#39;s a bit of design space left here that I hope to explore in the future with Supposition.jl&#33; In the mean time, moving from naive <code>String</code>-wrapper errors towards custom subtypes of <code>Exception</code> is definitely a boon; if not &#40;yet&#41; for Supposition.jl, then at least for your users :&#41;</p> <footer> <div id=meta > <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Sukera. Last modified: March 21, 2024. <a type="application/rss+xml" href="./feed.xml"> <img src="/assets/rss.svg" alt="RSS Feed" class=rss-icon /> </a> </div> <div id=love > Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>, the <a href="https://julialang.org">Julia programming language</a> and <span class=heart >‚ô•</span>! </div> </footer> </div> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script> <script> const setTheme = function (newTheme) { var prefersDarkScheme = window.matchMedia("(prefers-color-scheme: dark)"); var wasNull = newTheme === null; if (newTheme === null) { if (prefersDarkScheme.matches) { newTheme = "dark"; } else { newTheme = "light"; }; }; if (newTheme == "dark") { document.body.classList.toggle("light-theme", false); document.body.classList.toggle("dark-theme", true); document.querySelector(".theme-moon").style.display = "inline-block"; document.querySelector(".theme-sun").style.display = "none"; } else { document.body.classList.toggle("dark-theme", false); document.body.classList.toggle("light-theme", true); document.querySelector(".theme-sun").style.display = "inline-block"; document.querySelector(".theme-moon").style.display = "none"; } if (!wasNull) { localStorage.setItem("theme", newTheme); } }; var currentTheme = localStorage.getItem("theme"); console.log(currentTheme); setTheme(currentTheme); var btn = document.querySelector(".theme-toggle"); btn.addEventListener("click", function () { var theme = document.body.classList.contains("light-theme") ? "dark" : "light"; setTheme(theme); }); var prefersDarkScheme = window.matchMedia("(prefers-color-scheme: dark)"); prefersDarkScheme.addEventListener("change", function() {setTheme(localStorage.getItem("theme"))}); </script>