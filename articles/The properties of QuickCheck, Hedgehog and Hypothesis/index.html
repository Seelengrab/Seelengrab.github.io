<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/basic.css"> <link rel=stylesheet  href="/css/style.css"> <link rel=icon  href="/assets/favicon.png"> <title>The Properties of QuickCheck, Hedgehog and Hypothesis</title> <header> <a href="/" class=blog-name ><span>Voyage:</span><span id=title >The Properties of QuickCheck, Hedgehog and Hypothesis</span></a> <nav> <ul> <li><button class=theme-toggle > <div class=theme-sun >‚òÄÔ∏è</div> <div class=theme-moon >üåñ</div> </button> <li><a href="/articles/">Articles</a> <!--<li><a href="/tag/">Tags</a>--> <li><a href="/about/">About</a> </ul> <img src="/assets/hamburger.svg" id=menu-icon > </nav> </header> <ul class=franklin-content  id=tags > <li><a href='/tag/pbt/'>PBT</a><li><a href='/tag/quickcheck/'>QuickCheck</a><li><a href='/tag/hedgehog/'>Hedgehog</a><li><a href='/tag/hypothesis/'>Hypothesis</a><li><a href='/tag/testing/'>testing</a><li><a href='/tag/julia/'>julia</a></ul> <div class=franklin-content ><h1 id=the_properties_of_quickcheck_hedgehog_and_hypothesis ><a href="#the_properties_of_quickcheck_hedgehog_and_hypothesis" class=header-anchor >The Properties of QuickCheck, Hedgehog and Hypothesis</a></h1> <p>If you&#39;re writing software, chances are that you&#39;re also writing tests for that software in some form or another &#40;if you&#39;re not, you really should be&#41;. As far as testing frameworks go, there are quite a lot to choose from. They are often language specific, with various setup, tear-down and assertion steps, but most boil down to &quot;run my code with some specific input and see that it works&quot;.</p> <p>This is at face value a good approach, but limiting your testing to some small known cases can severely limit your ability to detect failures on unexpected input. This is where an approach called &quot;fuzz testing&quot; comes in; in a nutshell, &quot;fuzz testing&quot; is about exercising your code with random input and checking whether the code still works as expected. There is a downside to this, however: due to the random nature, failure cases can be extremely difficult to trace &amp; debug, since the generated inputs are often not well-structured. This is where a technique called &quot;Property Based Testing&quot; &#40;in the following abbreviated as &quot;PBT&quot;&#41; comes in: By generating input conforming to a given set of properties, the random input can be &quot;tamed&quot; a bit, by ensuring for a given test case only e.g. random even numbers are generated. While this ensures that input is more well-behaved, in the sense that it&#39;s less likely to encounter failures due to known-bad input, the generated test examples can still be very complicated to human eyes.</p> <p>This problem of &quot;too complicated test examples&quot; was first tackled by QuickCheck in 1999, with more recent work in the form of Hedgehog and Hypothesis refining the concept through different approaches. There are also various others that have tackled this problem in the literature, but in the interest of brevity and due to me not being familiar with them, I&#39;m going to focus on the three most well-known libraries, QuickCheck, Hedgehog and Hypothesis. This article is not intended to give an introduction to the libraries themselves, or how to use them to write tests. There are numerous resources online for that purpose already. Rather, I&#39;ll try to build some intuition for how each of these testing frameworks work conceptually and what their trade-offs are, in hopes of making the topic more accessible to others.</p> <p>If you&#39;re just here for a quick &quot;what&#39;s the differences&quot; kind of thing, there is a TL;DR at the bottom. How much that will help you if you&#39;re not already familiar with these frameworks is left as an exercise for the reader :&#41;</p> <div class="admonition note"><p class=admonition-title >Naming</p><p>There are a number of &#40;sometimes conflicting&#41; definitions of &quot;property testing&quot;. For the purposes of this article, property based testing refers to not only testing that some predicate holds, but also that the input is generated in some manner smarter than simple random generation, e.g. by taking failures into account that subsequently guide generation of new values. I&#39;d classify simple random generation of input values as purely fuzzing.</p> </div> <h2 id=the_general_flow ><a href="#the_general_flow" class=header-anchor >The general flow</a></h2> <p>The general flow of property based testing frameworks is:</p> <pre><code class="julia hljs"><span class=hljs-keyword >while</span> should_generate
    <span class=hljs-comment ># generate some object</span>
    obj = generate_obj()

    <span class=hljs-comment ># test the predicate</span>
    holds = predicate(obj)

    <span class=hljs-comment ># if it holds, just generate a new one</span>
    <span class=hljs-keyword >if</span> holds
        <span class=hljs-keyword >continue</span>
    <span class=hljs-keyword >end</span>

    <span class=hljs-comment ># if it doesn&#x27;t hold, shrink, and test the shrunk object until we&#x27;re done</span>
    <span class=hljs-keyword >while</span> should_shrink
        shrunk_obj = next_shrink(obj)
        holds = predicate(shrunk_obj)
        <span class=hljs-keyword >if</span> holds
            <span class=hljs-keyword >continue</span>
        <span class=hljs-keyword >else</span>
            <span class=hljs-comment ># in order to find shrinks of shrunk objects</span>
            obj = shrunk_obj
        <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span></code></pre> <p>We start out with an initial example generated by some <code>generate_obj</code> function and we test the predicate. If it holds, we restart, it it doesn&#39;t, we start repeatedly shrinking &amp; testing the shrunk objects.</p> <div class="admonition note"><p class=admonition-title >Shrinking? (Added on 2024-03-14)</p><p>&quot;Shrinking&quot; may sound a bit odd, but in the context of PBT it refers to transforming one object into a &quot;smaller&quot; one. &quot;Smaller&quot; is pretty arbitrary here - it can refer to literally a smaller footprint in memory, it can refer to fewer set bits, or any other metric you might want to come up with. The only important thing is that shrinking an object ends up at a fixed point that can&#39;t shrink anymore. There may be multiple such fixed points, in which case it&#39;s also important that any one given object always deterministically shrinks to the same fixed point &#40;for a given seed used for the pseudo random generator&#41;, lest the shrinking process is no longer reproducible.</p> </div> <p>Both <code>should_generate</code> and <code>should_shrink</code> are some form of cancellation of the entire process. This can be a timeout, an upper limit for how many samples should be taken, a combination of the two, or something else entirely. Suffice it to say, their purpose is to not get stuck in an infinite loop. If the user code in <code>predicate</code> loops endlessly, this will of course need to be cancelled through other means, but that is outside the purposes of this article.</p> <div class="admonition warning"><p class=admonition-title >Not production ready</p><p>The above pseudocode is only intended to illustrate the general flow of generation, testing &amp; shrinking - no library I&#39;m aware of actually uses a loop like that, in part because <code>next_shrink</code> is really ambiguous. Please don&#39;t use this as a template for how your own library should work.</p> </div> <h2 id=quickcheck_and_type_based_generation ><a href="#quickcheck_and_type_based_generation" class=header-anchor >QuickCheck and type based generation</a></h2> <p><a href="https://www.cse.chalmers.se/~rjmh/QuickCheck/">QuickCheck</a> is the &quot;grandfather&quot; of property based testing frameworks. Originally developed for the Haskell programming language, it was &#40;to my knowledge&#41; the first property based testing framework with shrinking &#40;the act of minimizing an example to a smaller one&#41; of examples in widespread use, at least in the Haskell ecosystem. At its core, QuickCheck works with types, both for generating values as well as shrinking them. To understand how this is done, we&#39;ll first have to take a &#40;very small&#41; excursion into type theory, to learn what a &quot;type&quot; even is &#40;don&#39;t worry, this won&#39;t go very deep&#41;, at least for the purposes of this article. </p> <p>Generally speaking, a type is a &#40;potentially infinitely large&#41; collection of values. For example, the <code>Int32</code> type in Julia &#40;corresponding to <code>int32_t</code> in C&#41; is a type representing all possible 32-bit integers from the interval <code>&#91;-&#40;2^31&#41;, 2^31 - 1&#93;</code>, encoded in Two&#39;s complement binary. Since the source set is finite, so is the type. As another example, the <code>String</code> type in Julia represents all possible UTF-8 strings, i.e. sequences of Unicode code points stored as UTF-8. Because there is only a minimum length but not a &#40;theoretical&#41; maximum, <code>String</code> is an example of a type that can potentially grow infinitely large, barring memory constraints.</p> <p>For <code>Int32</code>, generating an example is relatively trivial; just pick a random number from all valid instances. For <code>String</code>, you might start out with the empty string <code>&quot;&quot;</code>, flip a coin to decide whether you should generate more characters or stop generation and return. If you generate more, you simply concatenate it onto the end of the result and flip a coin again. This can of course be biased towards longer strings. Another way for generating <code>String</code>s would be to first generate a length and then generate that many code points.</p> <pre><code class="julia hljs">julia&gt; <span class=hljs-keyword >function</span> gen_string(;bias=<span class=hljs-number >0.9</span>)
           res = <span class=hljs-string >&quot;&quot;</span>
           <span class=hljs-keyword >while</span> <span class=hljs-literal >true</span>
               <span class=hljs-keyword >if</span> rand(<span class=hljs-built_in >Float64</span>) &gt;= bias
                   <span class=hljs-keyword >return</span> res
               <span class=hljs-keyword >end</span>
               res *= rand(<span class=hljs-built_in >Char</span>)
           <span class=hljs-keyword >end</span>
       <span class=hljs-keyword >end</span>
gen_string (generic <span class=hljs-keyword >function</span> with <span class=hljs-number >1</span> method)

julia&gt; <span class=hljs-keyword >using</span> Random <span class=hljs-comment ># for randstring</span>

julia&gt; <span class=hljs-keyword >function</span> gen_string_len(;min_len=<span class=hljs-number >0</span>, max_len=<span class=hljs-number >20</span>)
           len = rand(min_len:max_len)
           randstring(len)
       <span class=hljs-keyword >end</span>
gen_string_len (generic <span class=hljs-keyword >function</span> with <span class=hljs-number >1</span> method)</code></pre> <p>Both of these functions return a <code>String</code> instance, but the strings they generate have wildly different properties themselves. For instance, the first function can return arbitrary Unicode characters, while the second function &#40;as written&#41; defaults to only returning alphanumeric characters. Additionally, the strings returned by <code>gen_string</code> are truly able to be infinitely long, while the ones from <code>gen_string_len</code> are not only bounded by <code>max_len</code>, but also uniformly sampled from the interval <code>&#91;0, 20&#93;</code>. This is not the case for <code>gen_string</code>; the strings it generates are increasingly unlikely to be longer, so shorter strings are much more likely.</p> <p>This is a problem - which of these is better as the default for <code>String</code>? Or might an entirely different generator be better? In some cases, the alphanumeric nature of <code>gen_string_len</code> might be more appropriate than the arbitrary unicodeness of <code>gen_string</code>. In other cases, the potential for infinite length of <code>gen_string</code> could be more desirable than the limited nature of <code>gen_string_len</code>.</p> <p>Further, because both generating and shrinking rely on knowing that the object is a <code>String</code>, both of these shrink in the same way. For <code>String</code>, we can shrink the length by dropping any character or we can shrink any individual character. The property that strings generated by <code>gen_string_len</code> could only ever be alphanumeric is lost, and shrinking its string might result in strings like <code>&quot;\u0\u4&quot;</code> &#40;a string containing a NUL character, followed by an End Of Transmission character&#41; being generated, which could be catastrophic if passed to a C function expecting a string of length 2.</p> <p>You can solve this dilemma in QuickCheck by not actually returning a <code>String</code>, but a type that encodes these additional properties while inheriting all behaviour of <code>String</code> through the type classes prevalent in Haskell. This way, these generators can be distinguished, and their shrinking behaviour can be customized. The downside is that for each of these types, both a generator and a shrinker need to be written, and care has to be taken that the shrinker actually preserves the properties guaranteed by the generator.</p> <p>Languages that don&#39;t have type level support for type classes also can&#39;t easily use this approach. Strongly typed languages won&#39;t accept anything other than <code>String</code> in their function signatures &#40;if the function is limited to that type&#41;, so wrapping the output of either <code>gen_string</code> or <code>gen_string_len</code> in a new type isn&#39;t an option there. This means a different approach is needed - one that preserves the implicit properties of the generator function, while returning objects of the same type, ideally without having to duplicate the generation logic into shrinking.</p> <h2 id=hedgehog_and_integrated_shrinking ><a href="#hedgehog_and_integrated_shrinking" class=header-anchor >Hedgehog and integrated shrinking</a></h2> <p>In 2017, the Haskell library <a href="https://github.com/hedgehogqa/haskell-hedgehog">Hedgehog</a> set out to solve this dilemma through an approach called &quot;integrated shrinking&quot;. The core idea is instead of simply generating an object, testing the property you want to test, and then &#40;seperately&#41; shrink the object to a smaller instance, you generate <em>all possible shrinks</em> ahead of time. Since this is not generally feasibly &#40;e.g. in the case of infinite strings above&#41;, this is done lazily. The shrinking behaviour is thus integrated into the generating behaviour, &#40;almost&#41; eliminating code duplication between the generator and the shrinker, while simultaneously preserving all implicit properties that were present during generation. In practice, this is done not through naive combination of functions that directly generate random instances of whatever you want to generate, but by combining objects <em>representing</em> those generators and the shrunk values generated by them.</p> <p>In the end, an <code>Int32Generator</code> represents a generator for a tree of values, the root of which is the initially generated value and the children of each node being the shrunk values.</p> <p>For example, instead of having a type <code>EvenInt32</code> for generating &amp; shrinking even 32-bit integers &#40;which themselves are of type <code>EvenInt32</code>&#33;&#41;, you can simply take an existing <code>iseven</code> predicate and combine that with an <code>Int32Generator</code> to produce a new generator that also generates <code>Int32</code>:</p> <pre><code class="julia hljs">julia&gt; <span class=hljs-keyword >using</span> PropCheck <span class=hljs-comment ># my Hedgehog-like PBT library for Julia</span>

julia&gt; Int32Generator = itype(<span class=hljs-built_in >Int32</span>);

<span class=hljs-comment ># just generating a value gives us the entire (lazy) shrink tree</span>
julia&gt; generate(Int32Generator)
Tree(<span class=hljs-number >433258103</span>)

<span class=hljs-comment ># The tree contains Int32</span>
julia&gt; generate(Int32Generator) |&gt; eltype
<span class=hljs-built_in >Int32</span>

<span class=hljs-comment ># generate some examples &amp; look at their roots</span>
julia&gt; examples = [ root(generate(Int32Generator)) <span class=hljs-keyword >for</span> _ <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >1_000</span> ];

julia&gt; count(isodd, examples)
<span class=hljs-number >509</span>

julia&gt; count(iseven, examples)
<span class=hljs-number >491</span>

<span class=hljs-comment ># now do the same for a filtered generator</span>
julia&gt; even_Int32_generator = filter(iseven, Int32Generator);

<span class=hljs-comment ># the filtered tree still contains Int32</span>
julia&gt; generate(even_Int32_generator) |&gt; eltype
<span class=hljs-built_in >Int32</span>

<span class=hljs-comment ># all examples are even</span>
julia&gt; examples = [ root(generate(even_Int32_generator)) <span class=hljs-keyword >for</span> _ <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >1_000</span> ];

julia&gt; count(isodd, examples)
<span class=hljs-number >0</span>

julia&gt; count(iseven, examples)
<span class=hljs-number >1000</span></code></pre> <p>Generating a value from this filtered generator then ensures the predicate holds not only for the initial value, but also for any shrunken values. This eliminates the need for a specialized shrinking function for even integers, since you can simply reuse the shrinking function for <code>Int32</code> and just have to apply the filtering step before producing a value, trying the next available shrunk value if the predicate passed to <code>filter</code> doesn&#39;t hold. Moreover, <code>even_Int32_generator</code> still generates proper <code>Int32</code> objects, that just all &quot;happen to be&quot; even.</p> <pre><code class="julia hljs"><span class=hljs-comment ># look at the first 1000 subtrees</span>
julia&gt; examples = map(root, Iterators.take(PropCheck.subtrees(generate(even_Int32_generator)), <span class=hljs-number >1_000</span>));

julia&gt; count(isodd, examples)
<span class=hljs-number >0</span>

julia&gt; count(iseven, examples)
<span class=hljs-number >1000</span></code></pre> <p>This makes the approach suitable for strongly typed languages without type classes&#33; If you want to play around with this in Julia, check out <a href="https://seelengrab.github.io/PropCheck.jl/stable/">PropCheck.jl</a>, my Hedgehog inspired port of this approach to Julia. Note that I&#39;m working on a replacement for PropCheck.jl, so while it&#39;s good to get your feet wet with property based testing, better things are on the horizon ;&#41;</p> <h3 id=downsides_of_combinations ><a href="#downsides_of_combinations" class=header-anchor >Downsides of combinations</a></h3> <p>This approach is not all wonderful though. While Hedgehog enables developers to combine generators without the need for additional wrapper types, the approach taken exposes a flaw that also shows up for more complicated objects in QuickCheck: When you want to generate an object that depends on more than one generated parent object &#40;say, the length of a string and the possible characters for each position in that string&#41;, how should the resulting object shrink? How can Hedgehog generically combine the implicit shrinking trees of two such generators?</p> <p>To illustrate, take the <code>String</code> example from earlier, where we first generated a length and then the individual elements for each index in the string. If we want to shrink the resulting string, we can either shrink the length, or any given character in the string. Naively picking one or the other first means that we can&#39;t then go back and shrink something else, without sacrificing the existing progress we made along the current shrinking progress - after all, the entire shrink tree is determined at the point of generation, not when shrinking the value. If we first shrink the length, we have to continue shrinking the length. If we first shrink the generator that produces elements, we have to continue shrinking the elements and can&#39;t start shrinking the length. This can result in bad shrinking results if we&#39;re getting stuck in a local minima of the shrinking process. With objects being combined from more and more parts, this quickly becomes infeasible in terms of quality of shrinks.</p> <p>No, in order to shrink properly Hedgehog must look into the generators, take out their generator functions &amp; shrinking functions, combine each and return an entirely new generator with a new &#40;combined&#41; shrinking function, creating an entirely different shrinking tree. This works, but is very complicated to implement. I suspect that this is the main reason Hedgehog is seldom used outside of Haskell. There are a number of ports made by the community, but they seem to be less sophisticated/well maintained than the Haskell counterpart. The Scala package linked to from the main Hedgehog website seems to be a dead link now.</p> <p>It should be noted that this same problem also occurs when trying to combine generators &amp; shrinkers of QuickCheck. In some sense the problem is worse there, because the shrinker has no knowledge of the properties that were implicit to the <em>other</em> generators when trying to combine shrinkers. Everything needs a bespoke solution.</p> <p>If you want to read more about this problem, I can recommend <a href="https://well-typed.com/blog/2019/05/integrated-shrinking/">this article</a> by Edsko de Vries, which was instrumental in my understanding of how Hedgehog works. The article goes into much more depth and very likely explains the subtleties involved with this approach better than this short description ever could. Be aware that it&#39;s dense with Haskell language though.</p> <h2 id=hypothesis_and_choice_sequences ><a href="#hypothesis_and_choice_sequences" class=header-anchor >Hypothesis and choice sequences</a></h2> <p>A few years before Hedgehog was released, there was another contender for property based testing. Unlike Hedgehog &amp; QuickCheck which came from the functional programming community, <a href="https://github.com/hypothesisworks/hypothesis">Hypothesis</a> is a Python project - and perhaps because of that, it takes an entirely different approach compared to the mathematically derived inner workings of these Haskell libraries.</p> <p>Unlike Hedgehog &amp; QuickCheck, Hypothesis internally places great emphasis on explicit management of the fact that it is a <em>testing framework</em>, and that there&#39;s associated state with one test execution. This is taken advantage of to allow a feature that neither Hedgehog nor QuickCheck have - dynamically manipulating the entire shrinking state &amp; value generation, even while inside of a test. In particular, this means creating new values dependent on previously input values and having their influence on the outcome of the testcase also influence shrinking behaviour of the original value.</p> <p>For QuickCheck it is fairly obvious to see why it can&#39;t do this, since shrinking &amp; generation are separated completely and the way a given test value was generated is not exposed inside of the test at all. For Hedgehog, this is a bit more subtle - it&#39;s possible to get access to the original shrink tree, but merging that with an entirely new shrink tree is highly nontrivial and might require reaching across different call stacks. The resulting API is also incredibly unwieldy, since a user needs to be intimately familiar with how Hedgehog works internally to be able to correctly combine these shrink trees by hand. Of course, this again is a bit easier in Haskell because of its laziness, which allows some easier access to the original shrink tree than in other statically typed languages.</p> <p>Hypothesis solves this issue elegantly, by decoupling the choices taken during generation from the actual generation of values entirely - it opts to track the entire decision history explicitly as a choice sequence, which is passed into each test case too. This allows simply taking that choice sequence, adding arbitrary choices and using those to generate new values which will correctly influence all other choices taken too.</p> <p>To do this, Hypothesis has users compose so called &quot;strategies&quot;. These strategies describe how to generate objects of a given type, with a given distribution, etc. One such strategy is <code>data&#40;&#41;</code>, allowing access to <em>all possible strategies</em> in the process of running the testcase itself. Here&#39;s an example, taken from the <a href="https://hypothesis.readthedocs.io/en/latest/data.html#drawing-interactively-in-tests">Hypothesis documentation</a>:</p> <pre><code class="python hljs"><span class=hljs-meta >@given(<span class=hljs-params >data(<span class=hljs-params ></span>)</span>)</span>
<span class=hljs-keyword >def</span> <span class="hljs-title function_">test_draw_sequentially</span>(<span class=hljs-params >data</span>):
    x = data.draw(integers())
    y = data.draw(integers(min_value=x))
    <span class=hljs-keyword >assert</span> x &lt; y</code></pre> <p>Here, <code>data</code> represents any possible drawing strategy, effectively saying &quot;add another choice using the given strategy to the choice sequence&quot;. The <code>assert</code> at the end serves as the marker that Hypothesis looks to falsify.</p> <p>Ultimately what shrinks is not the objects themselves, but the <em>choice sequence</em> leading to those objects&#33; By replaying a modified choice sequence &#40;and thus constructing entirely new instances of the required objects&#41;, this modified choice sequence leads to shrunken values being passed into the testcase. This modified choice sequence then itself correctly leads to shrunken values being produced inside of the testcase as well. An extensive description of this approach can be found in <a href="https://doi.org/10.4230/LIPIcs.ECOOP.2020.13">&quot;Test-Case Reduction via Test-Case Generation: Insights From the Hypothesis Reducer&quot;</a> by MacIver &amp; Donaldson, the original authors of Hypothesis - an absolute fantastic and easy to follow paper.</p> <p>This kind of internal test-case reduction, as the authors call it, has other advantages as well: because the choice sequence is completely decoupled from actually creating any objects, a number of different ways to judge how well an example does open up. For instance, Hypothesis supports an arbitrary scoring function to be used during execution, which Hypothesis will then try to maximize. This can be extremely useful for guiding Hypothesis towards examples that are more likely to be a good counterexample, in case the example in question is itself very complex and the generated example doesn&#39;t actually fail the test. In a sense, this combats the &quot;curse of dimensionality&quot; often seen in machine learning too, since &quot;find the minimal counterexample reproducing a failure&quot; really is an optimization problem in disguise. It&#39;s not difficult to imagine that this choice sequence could even be used as input to an LLM, asking it to produce similar sequences that produce failure cases as well. One downside of course is that the choice sequences are coupled with the given testcase that generated them, resulting in really bad transfer of any learned property between testcases. Neither of these optimization approaches are per se possible with the forced tree structure of QuickCheck and Hedgehog, since there is no way to transmit this additional information to the testing framework, let alone have it act on that information to steer shrinking. The state is implicit after all, not explicit.</p> <p>However, it should in principle be possible to modify the expected signature of the frameworks to return a more complicated structure including such a targeting score as well as the result of the predicate to inform decisions about which branches are more interesting for future expansion. Whether that information can be integrated into the respective shrinking processes is another matter though - I suspect it should be easier to do in QuickCheck than in Hedgehog, since in Hedgehog the shrinking trees &#40;and their order&#33;&#41; is already predetermined before the test starts.</p> <h2 id=conclusion ><a href="#conclusion" class=header-anchor >Conclusion</a></h2> <p>Phew, that was a lot&#33; Let&#39;s summarize a bit:</p> <ul> <li><p>QuickCheck/Type based</p> <ul> <li><p>Pros</p> <ul> <li><p>Simple mental model, easy to implement</p> <li><p>Total customizability of generation &amp; shrinking</p> </ul> <li><p>Cons</p> <ul> <li><p>only type based</p> <li><p>needs careful design of both generators &amp; shrinkers</p> <li><p>duplication of logic between generators &amp; shrinkrs</p> <li><p>hard to combine generators &amp; shrinkers in a generic way</p> <li><p>difficult to use in strongly typed languages without type classes </p> </ul> </ul> <li><p>Hedgehog/Tree manipulation based</p> <ul> <li><p>Pros</p> <ul> <li><p>Easy combination of generators &amp; shrinkers</p> <li><p>&#40;Almost&#41; no duplication of logic between generators &amp; shrinkers</p> <li><p>Can fall back to type-based generation &amp; shrinking</p> </ul> <li><p>Cons</p> <ul> <li><p>Mental model is difficult to work with/extend/customize</p> <li><p>No flexibility to influence/guide shrinking behavior on a per-testcase basis</p> <li><p>Difficult to port to other languages due to the lazy structure of the trees</p> </ul> </ul> <li><p>Hypothesis/Choice sequences</p> <ul> <li><p>Pros</p> <ul> <li><p>Very flexible customization possibilities for both generation and shrinking</p> <li><p>Composes primitives extremely well</p> <li><p>Easy to explain how to customize</p> <li><p>Trivial to replay/cache known failures</p> <li><p>All shrunk values could have been generated from the given generators in some way</p> </ul> <li><p>Cons</p> <ul> <li><p>No type-based shrinking out of the box, needs additional features to <em>exclusively</em> shrink a specific object in a specific way &#40;and nothing else&#33;&#41;</p> <li><p>Shrinking can, out of the box, only be steered passively</p> <li><p>Somewhat involved to implement at first</p> </ul> </ul> </ul> <p>Overall, Hypothesis ends up being the most powerful &amp; most extensible of all of these. The historical relation between QuickCheck and Hedgehog and how the latter tries to address problems of the former is evident. At the same time, the differences in approach make it clear how Hypothesis has little, if any, connection to the design concerns &amp; features that the Haskell projects take advantage of. This should not be surprising, considering just how different the approaches to problem solving in Haskell and Python truly are.</p> <p>Since this article has gotten quite long, I&#39;ll end it here. I&#39;m definitely going to explore choice sequence based shrinking more in the future though&#33; Concretely, I think this approach pairs very well with the powerful compile time reflection capabilities we have in Julia.. :&#41; Much better than QuickCheck or Hedgehog based shrinking, at least.</p> <footer> <div id=meta > <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Sukera. Last modified: June 10, 2024. <a type="application/rss+xml" href="/feed.xml"> <img src="/assets/rss.svg" alt="RSS Feed" class=rss-icon /> </a> </div> <div id=love > Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>, the <a href="https://julialang.org">Julia programming language</a> and <span class=heart >‚ô•</span>! </div> </footer> </div> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script> <script> const setTheme = function (newTheme) { var prefersDarkScheme = window.matchMedia("(prefers-color-scheme: dark)"); var wasNull = newTheme === null; if (newTheme === null) { if (prefersDarkScheme.matches) { newTheme = "dark"; } else { newTheme = "light"; }; }; if (newTheme == "dark") { document.body.classList.toggle("light-theme", false); document.body.classList.toggle("dark-theme", true); document.querySelector(".theme-moon").style.display = "inline-block"; document.querySelector(".theme-sun").style.display = "none"; } else { document.body.classList.toggle("dark-theme", false); document.body.classList.toggle("light-theme", true); document.querySelector(".theme-sun").style.display = "inline-block"; document.querySelector(".theme-moon").style.display = "none"; } if (!wasNull) { localStorage.setItem("theme", newTheme); } }; var currentTheme = localStorage.getItem("theme"); console.log(currentTheme); setTheme(currentTheme); var btn = document.querySelector(".theme-toggle"); btn.addEventListener("click", function () { var theme = document.body.classList.contains("light-theme") ? "dark" : "light"; setTheme(theme); }); var prefersDarkScheme = window.matchMedia("(prefers-color-scheme: dark)"); prefersDarkScheme.addEventListener("change", function() {setTheme(localStorage.getItem("theme"))}); </script>